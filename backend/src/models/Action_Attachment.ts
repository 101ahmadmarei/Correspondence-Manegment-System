'use strict';
import { Model } from 'sequelize';

interface IAttachments {
    id: number;
    // actionId: number; // references `Action(`id`)`
    fileName: string; /* fileName: random generated filename (Will be generated by us, ex: "workflowID_actionID_RandomNumber.ext") 
    (fileName will be including file extension, for example "myfile.txt")
    */
    fileType: string; // (the MIME type)
    description: string | undefined;
    /* description: This is the original filename on the user's PC, so this will be stored in the table in order to show to the clients in the front-end. */
    size: number; //file size in bytes
}

module.exports = (sequelize: any, DataTypes: any) => {
    class Action_Attachment extends Model<IAttachments>
        implements IAttachments {

        id!: IAttachments["id"];
        // actionId!: // references `Action(`id`)`
        fileName!: IAttachments["fileName"];//(will be including file extension, for example "myfile.txt")
        fileType!: IAttachments["fileType"]; // (the MIME type)
        description: IAttachments["description"];
        size!: IAttachments["size"];

        static associate(models: any) {
            // define association here:
            // -------------- {#1: Action_Attachment belongs to Action} --------------
            Action_Attachment.belongsTo(models.Action, { as: "action", });
            // NOTE: { as: "action" } will consider the target model name "action" instead 
            // of "Action_Attachment", so it will add field: `actionId` to the `Action_Attachment` model.
            // So, `actionId` is a FK that references `Action`(`id`),
        }
    }// end class

    Action_Attachment.init({
        id: {
            type: DataTypes.INTEGER(11).UNSIGNED,
            primaryKey: true,
            allowNull: false,
            autoIncrement: true,
        },
        fileName: {
            type: DataTypes.STRING, //default VARCHAR(255)
            //(will be including file extension, for example "myfile.txt")
            allowNull: false,
        },
        fileType: {
            type: DataTypes.STRING, //should I make the type: DataTypes.ENUM ???
            allowNull: false,
        },
        description: {
            type: DataTypes.STRING, //default VARCHAR(255)
            allowNull: true,
            // defaultValue: "UnnamedFile.ext"
        },
        size: {
            type: DataTypes.INTEGER(11).UNSIGNED,
            allowNull: true,
        }
    }, {
        sequelize, //this is our Sequelize instance (our db connection instance)
        modelName: "Action_Attachment", //tableName will become: Action_Attachments/
        freezeTableName: true,
        tableName: "Actions_Attachments"
        // initialAutoIncrement: "1000", //must be string | undefined
    });

    return Action_Attachment;
};

/*
If we are talking about file upload storage for example I will always store the following fields:

File - varbinary(MAX)
FileName - nvarchar(255) (including file extension, for example "myfile.txt")
FileType - nvarchar(255) (the MIME type)
The MIME type is important if it is a web based application and you want to allow download of the files at some point. Having the MIME type allow you to tell the browser how to best handle the file.

So the direct answer to your question is to save both the MIME type and the Extension. The reason being that you cannot ensure the correct file extension has been supplied so you need the MIME type to identify the file type. But you should store the extension with the filename so as you can provide a valid filename at download time.
*/


